# Effective C++

## 1.习惯C++

### 条款01：视C++为一个语言联邦

即C++是由C，Object-Oriented C++,Template C++和STL四个次语言所组成的。

### 条款02：尽量以const,enum,inline代替#define

最好用编译器来代替预处理器，对于形似函数的宏（macros），最好改用inline函数代替#defines

### 条款03：尽可能使用const

### 条款04：确定对象被使用前已被初始化

C++有着十分固定的成员初始化次序，base classes（基类）更早与derived classes（派生类）被初始化。

**而class的成员变量总是以其声明次序被初始化。**

**static对象的析构函数会在main()结束时自动被调用。**

## 2.构造/析构/赋值运算

### 条款05：了解C++默默编写并调用哪些函数

如果自己没有声明，编译器就会为类声明一个copy构造函数，一个copy assignment操作符和一个析构函数，只有当这些函数被调用时，他们才会被编译器创建出来,若声明时漏掉了其中一项，编译器也会补上该项。

```c++
class Empty{};
//等效于
class Empty{
    public:
    Empty(){....}						   //default构造函数
    Empty(const Empty& rhs){....}		   //copy构造函数
    ~Empty(){...}						   //析构函数
    Empty& operator=(const Empty& rhs){...}//copy assignment操作符
};
```

### 条款06：若不想使用编译器自动生成的函数，就该明确拒绝

所有编译器产出的函数都是**public**。为了阻止这些函数被创建出来，必须自行声明他们，而这些函数最好声明为**private**，可以成功阻止胡乱的调用。

但是因为**member**函数和friend函数，其可能依旧可以调用**private**函数，**所以可以将成员函数声明为private但是故意不实现他们。**

### 条款07：为多态基类声明virtual析构函数

当给基类定义了一个**virtual析构函数**时，在此后删除其派生类对象时就会销毁所有对象，包括所有派生类成分。

当然，若此类不作为基类使用，那就不要声明virtual析构函数。

### 条款08：别让异常逃离析构函数

 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下（不传播）他们或者结束程序。

### 条款09：绝不在构造和析构过程中调用virtual函数

由于基类的构造函数的执行更早与派生类的构造函数，当基类构造函数执行时派生类的成员函数尚未初始化，此时派生类的对象是基类而不是派生类。对于析构函数也是同理。 

### 条款10：令operator=返回一个reference to *this（就是令赋值操作符返回一个reference to *this）

### 条款11：在复制操作中处理“自我赋值”

​                                   

























