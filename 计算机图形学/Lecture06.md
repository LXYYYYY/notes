# 计算机图形学

## Lecture 06  光栅化02	Rasterization:Antialiasing and Z-Buffering

### 1. 抗锯齿(反走样) Antialiasing

![](https://pic3.zhimg.com/80/v2-1c70f691f7713beb3370ac3ae7875a86_720w.jpg)

利用上一节的三角形光栅化算法之后，我们可以把该三角形表示成一个如下图所示的像素点集合

![img](https://pic1.zhimg.com/80/v2-ac4a62fc331e24c25bb8c6b4c949ce5c_720w.jpg)

这里就出现了图像的走样，**用有限离散的像素点去逼近连续的三角形**就会出现这种情况。

#### 1.1  超采样反走样 SSAA

SSAA的想法其实是非常直观的，如果有限离散像素点逼近结果不好，那么我们用更多的采样点去逼近不就会得到更好的结果了吗？所以根据这个思想我们可以把原来的每个像素点进行细分，比如下例中，我们讲每个像素点细分成了4个采样点：

![img](https://pic2.zhimg.com/80/v2-455a588760f411fe902cbc4e1bd41721_720w.jpg)

![img](https://pic4.zhimg.com/80/v2-e1f2115bf626bbe2b4717069e094121f_720w.jpg)

我们根据每个采样点来进行shading（该概念还未提及，可以理解为计算每个像素点的颜色的过程，当然这里是一个纯红色的三角形，如果该点在三角形内，它的颜色值可以直接得到为（1，0，0）），这样得到了每个采样点的颜色之后，我们讲每个像素点内部所细分的采样点的颜色值全部加起来再求均值，作为该像素点的抗走样之后的颜色值！结果如下：

![img](https://pic3.zhimg.com/80/v2-17682c20fc55972d5cfb611a0693b506_720w.jpg)



仔细观察可以发现因为将4个采样点的颜色求均值的之后，靠近三角形边缘的像素点有的变淡了，从宏观角度来看的话，这个锯齿就会变得不那么明显了。可以看看这样一个具体例子。

![img](https://pic2.zhimg.com/80/v2-2ff5d77656a5ac08991aa42807d7cc55_720w.jpg)

(tips：SSAA并不局限于分成4个，也可以分更多的，可以自己决定，游戏里面其实就有一个抗锯齿的选项，其中的 ![[公式]](https://www.zhihu.com/equation?tex=%5Ctimes2%2C%5Ctimes3%2C%5Ctimes4),分别代表的就是4个，9个，16个采样点，显然采样点越多抗锯齿效果越好，但计算负担也会随之增加）。

#### 1.2  多采样反走样 MSAA

MSAA其实是对SSAA的一个改进，显然SSAA的计算量是非常大的，每个像素点分成4个采样点，我们就要进行4次的shading来计算颜色，额外多了4倍的计算量，如何降低它呢？

MSAA的做法也很容易理解，我们依然同样会分采样点，但是只会去计算究竟有几个采样点会被三角形cover，计算颜色的时候只会利用像素中心坐标计算一次颜色(即所有的信息都会被插值到像素中心然后取计算颜色)，如下图：



![img](https://pic2.zhimg.com/80/v2-96a6fae11603c4b2e02da6389adc3f59_720w.jpg)

只有两个采样点被我们的三角形cover了，将该像素中心计算出来的颜色值乘以50%即可，这样大大减少了计算量，不必对每个子采样点都进行着色计算，并且得到反走样效果也是很不错的。

### 2.  深度缓冲   Z Buffer

对于同一个像素点，可能对应了不同三角形上的点，那么对于这个点就需要对显示哪个三角形做一个选择，那么很明显，优先显示距离更近的点。这里的远近就取决于三角形的深度值。 

但是对于不同的三角形之间的远近关系可能有混叠，所以最好还是取像素的远近关系，离摄像头最近的像素点就显示。

那就需要一个额外的缓冲来存深度信息，也就是 **frame buffer** 用来存颜色值，而 **depth buffer** 用来存深度值。

所以 **Z-Buffer** 算法的基本思想就是：

**1. Z-Buffer算法需要为每个像素点维持一个深度数组记为zbuffer，其每个位置初始值置为无穷大（即离摄像机无穷远）。**

**2. 随后我们遍历每个三角形面上的每一个像素点[x,y]，如果该像素点的深度值z，小于zbuffer[x,y]中的值，则更新zbuffer[x,y]值为该点深度值z，并同时更新该像素点[x,y]的颜色为该三角形面上的该点的颜色。**

那么对于遮挡的顺序的结果伪代码计算为:.

![img](https://pic3.zhimg.com/80/v2-7fd992f798f0cc5fea8ddef6c76622ce_720w.jpg)

一个计算实例如下：	

 ![img](https://pic4.zhimg.com/80/v2-7b40749adc637007fa0a7759da980f8b_720w.jpg)